"use strict";(self.webpackChunksrcful_documentation=self.webpackChunksrcful_documentation||[]).push([[890],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return a?n.createElement(m,o(o({ref:t},c),{},{components:a})):n.createElement(m,o({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8037:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={sidebar_position:1,slug:"/developer/hardware",pagination_prev:null},o="Hardware/Firmware Guide",s={unversionedId:"developer/hardware",id:"developer/hardware",title:"Hardware/Firmware Guide",description:"This document describes basic requirements for a device to be compatible with the Sourceful Energy Network (SEN). The focus is for firmware compatibility. Document is under development.",source:"@site/docs/developer/hardware.md",sourceDirName:"developer",slug:"/developer/hardware",permalink:"/developer/hardware",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"/developer/hardware",pagination_prev:null},sidebar:"tutorialSidebar",next:{title:"Design manual and press",permalink:"/developer/design-manual"}},l={},p=[{value:"Basics",id:"basics",level:2},{value:"Examples",id:"examples",level:2},{value:"ESP32",id:"esp32",level:3},{value:"Sourceful Energy Gateway Firmware",id:"sourceful-energy-gateway-firmware",level:3},{value:"Core Specifications",id:"core-specifications",level:2},{value:"Software Implementation",id:"software-implementation",level:2},{value:"Python Example",id:"python-example",level:3},{value:"SEN Onboarding",id:"sen-onboarding",level:2},{value:"Inception",id:"inception",level:3},{value:"Location",id:"location",level:3},{value:"User Experience",id:"user-experience",level:2},{value:"Local Interface",id:"local-interface",level:3},{value:"Bespoke App",id:"bespoke-app",level:3},{value:"Sourceful Energy App",id:"sourceful-energy-app",level:3},{value:"Network Connectivity",id:"network-connectivity",level:3},{value:"Inception",id:"inception-1",level:2},{value:"Header",id:"header",level:2},{value:"Energy Meter Header Example",id:"energy-meter-header-example",level:3},{value:"Payload",id:"payload",level:2},{value:"Energy Meter Payload Example",id:"energy-meter-payload-example",level:3},{value:"Signature",id:"signature",level:2},{value:"Full Signed JWT Energy Meter Example",id:"full-signed-jwt-energy-meter-example",level:3}],c={toc:p},d="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"hardwarefirmware-guide"},"Hardware/Firmware Guide"),(0,i.kt)("p",null,"This document describes basic requirements for a device to be compatible with the Sourceful Energy Network (SEN). The focus is for firmware compatibility. Document is under development."),(0,i.kt)("p",null,"While there are many types of devices that can be connected to the SEN they are all regarded as gateways in the SEN, the gateway is then responsible for collecting data and controlling one or several energy resources. Some gateways are more special, e.g., a p1 meter and some are more generic in nature, e.g., the Sourceful Energy Gateway."),(0,i.kt)("p",null,"The firmware for the Sourceful Energy Gateway is open source and can serve as a generic reference implementation: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/srcfl/srcful-gateway/"},"https://github.com/srcfl/srcful-gateway/")),(0,i.kt)("h2",{id:"basics"},"Basics"),(0,i.kt)("p",null,"A gateway needs to be identifiable and provide a public key. Gateway id and public key needs to be registered with SEN before the gateway is usable. Internally a gateway needs to maintain the private key and sign data."),(0,i.kt)("p",null,"All hardware devices will need to be audited and tested before granted access to the network and public release."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("h3",{id:"esp32"},"ESP32"),(0,i.kt)("p",null,"There is an ESP32 example project under development at: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/srcfl/srcful-esp32-firmware-example"},"https://github.com/srcfl/srcful-esp32-firmware-example")),(0,i.kt)("p",null,"This example shows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Handling of cryptographic keys in software"),(0,i.kt)("li",{parentName:"ul"},"Construction and signing of data JWTs"),(0,i.kt)("li",{parentName:"ul"},"Construction and signing of Inception message"),(0,i.kt)("li",{parentName:"ul"},"BLE message protocol"),(0,i.kt)("li",{parentName:"ul"},"Important REST endpoints for onboarding (under construction)"),(0,i.kt)("li",{parentName:"ul"},"Safe storage of private key (TODO)")),(0,i.kt)("h3",{id:"sourceful-energy-gateway-firmware"},"Sourceful Energy Gateway Firmware"),(0,i.kt)("p",null,"While in development the full firmware of the Sourceful Energy Gateway is open source and can work as a reference implementation. This firmware is suitable for micro computers such as raspberry pi 4+ that can run containerized applications."),(0,i.kt)("p",null,"You find the project here: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/srcfl/srcful-gateway"},"https://github.com/srcfl/srcful-gateway")),(0,i.kt)("h1",{id:"cryptographic-implementation"},"Cryptographic Implementation"),(0,i.kt)("p",null,"The SEN relies on cryptographic signatures to validate the source of data, ownership of gateways etc."),(0,i.kt)("p",null,"The SEN uses ECDSA (Elliptic Curve Digital Signature Algorithm) for cryptographic operations, implemented in two ways:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Hardware-based using ATECC608A/B secure elements"),(0,i.kt)("li",{parentName:"ol"},"Software-based, e.g., using Python's ",(0,i.kt)("inlineCode",{parentName:"li"},"ecdsa")," library")),(0,i.kt)("h2",{id:"core-specifications"},"Core Specifications"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Algorithm"),": ECDSA"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Curve"),": SECP256r1 "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Key Sizes"),": ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Private Key: 32 bytes (256 bits)"),(0,i.kt)("li",{parentName:"ul"},"Public Key: 64 bytes (x,y coordinates, 32 bytes each)")))),(0,i.kt)("h2",{id:"software-implementation"},"Software Implementation"),(0,i.kt)("p",null,"If software keys are used it is imperative that the private key is stored in a secure way. The private key must not be stored in plain text in files, code nor as environment variables."),(0,i.kt)("h3",{id:"python-example"},"Python Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import json\nimport base64\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import ec, utils\n\ndef base64url_encode(data: bytes) -> str:\n    return base64.urlsafe_b64encode(data).rstrip(b\'=\').decode(\'utf-8\')\n\n# Generate a new private key\nprivate_key = ec.generate_private_key(ec.SECP256R1())\npublic_key = private_key.public_key()\n\n# Get the private key number\nprivate_numbers = private_key.private_numbers()\nprivate_key_hex = f"{private_numbers.private_value:064x}"\nprint(f"Private key: {private_key_hex}")\n\n# Get the public key coordinates\npublic_numbers = public_key.public_numbers()\npublic_key_hex = f"{public_numbers.x:064x}{public_numbers.y:064x}"\nprint(f"Public key: {public_key_hex}")\n\n# Create a JWT\nheader = {\n    "alg": "ES256",\n    "typ": "JWT",\n    "device": "test123",\n    "opr": "testing"\n}\n\npayload = {\n    "message": "Hello, World!",\n    "timestamp": 1234567890\n}\n\n# Encode header and payload\nheader_b64 = base64url_encode(json.dumps(header).encode())\npayload_b64 = base64url_encode(json.dumps(payload).encode())\n\n# Create message to sign\nmessage = f"{header_b64}.{payload_b64}".encode()\n\n# Hash the message\ndigest = hashes.Hash(hashes.SHA256())\ndigest.update(message)\nmessage_hash = digest.finalize()\n\n# Sign the message\nsignature = private_key.sign(\n    message_hash,\n    ec.ECDSA(utils.Prehashed(hashes.SHA256()))\n)\n\n# Convert DER signature to raw R,S format\nr, s = utils.decode_dss_signature(signature)\nsignature_bytes = r.to_bytes(32, byteorder=\'big\') + s.to_bytes(32, byteorder=\'big\')\nsignature_b64 = base64url_encode(signature_bytes)\n\n# Create final JWT\njwt = f"{header_b64}.{payload_b64}.{signature_b64}"\nprint(f"\\nGenerated JWT:\\n{jwt}")\n')),(0,i.kt)("h2",{id:"sen-onboarding"},"SEN Onboarding"),(0,i.kt)("p",null,"Gateway id and public key needs to be registered with SEN before the gateway is usable. Basically, the id and public key is submitted to the network and then registered. In the future, this procedure will be automated through the developer platform and developer APIs."),(0,i.kt)("p",null,"Before a gateway is usable on the SEN, it must be tied to a wallet public key (inception), e.g., the user's wallet, and finally be given a correct physical location."),(0,i.kt)("h3",{id:"inception"},"Inception"),(0,i.kt)("p",null,"The gateway must accept the wallet public key and add its own id and a cryptographic signature. The gateway then initializes the device in the SEN API."),(0,i.kt)("p",null,"When the gateway is tied to a wallet, further calls to the SEN API will fail."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'mutation {\n      gatewayInception {\n        initialize(gatewayInitialization:{idAndWallet:"gateway_id:wallet_public_key", signature:"signature_of_idAndWallet"}) {\n          initialized\n        }\n      }\n    }\n')),(0,i.kt)("h3",{id:"location"},"Location"),(0,i.kt)("p",null,"The location for a gateway is important from a standpoint of validity. The Network relies on accurate positions of resources, to e.g., know that a resource is part of a particular area."),(0,i.kt)("p",null,"Setting the location for a gateway is based on a signature from the owning wallet (see Inception above). The gateway hardware/keys are not part of this, and this part can thus be handled in different ways. The Sourceful Energy App offers setting the location of a device for all gateways a wallet has been paired with."),(0,i.kt)("h2",{id:"user-experience"},"User Experience"),(0,i.kt)("p",null,"The user experience of onboarding can vary depending on the level of integration desired. Basically, it is up to each gateway firmware to provide the means for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Network connectivity - most devices would need some kind of Network access, e.g., WiFi credentials"),(0,i.kt)("li",{parentName:"ul"},"Inception/Initialisation"),(0,i.kt)("li",{parentName:"ul"},"Location (Optional)")),(0,i.kt)("h3",{id:"local-interface"},"Local Interface"),(0,i.kt)("p",null,"In the simplest form, this is handled via the gateway itself, via a local interface, e.g., an internal webpage. This may be sufficient for a deeply technical product, possibly with other complex configuration of connected devices etc. The main caveat for a unified user experience in this case is the integration of the wallet key. There are, however, modules for most popular web frameworks that can handle this seamlessly. In the simplest case, the user will need to copy paste the wallet public key into the local interface. Depending on needs, the local interface can be as advanced as needed and provide a full user experience by utilizing the data egress of the SEN Network to do visualizations etc."),(0,i.kt)("h3",{id:"bespoke-app"},"Bespoke App"),(0,i.kt)("p",null,"For a more non-technical user experience, a bespoke App that communicates with the gateway may be developed."),(0,i.kt)("h3",{id:"sourceful-energy-app"},"Sourceful Energy App"),(0,i.kt)("p",null,"The onboarding may be integrated into the Sourceful Energy App (SEA) for a seamless experience into the Network. Using the SEA, the user can always set location of an owned gateway. The SEA also offers Network connectivity, inception integration of the gateway, and a walletless mode (for users that do not have a separate crypto wallet) but this requires additional functionality in the gateway firmware. There are two basic ways to connect the client and the gateway for onboarding, soft ap or BLE. We recoomend ble for a smoother user experience and compatibility with web apps."),(0,i.kt)("p",null,"Wifi provisioning is an optional step and is placed last. The SEA does not require the gateway to have internet connectivity to be onboarded to the network per se (but it would obviously need to send data to the network at some point to be useful). Low spec devices can therefore do the onboarding using e.g. BLE only, no messages needs to be sent from the gateway to the backend during this process. The advantage is that the gateway does not need to maintain e.g. BLE stack and SSL Certificates at the same time. In essence the gateway can become operational after it has a wifi connection and BLE has been stoped."),(0,i.kt)("p",null,"Onboarding via BLE looks like this:"),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    participant U as User\n    participant C as Client\n    participant G as Gateway\n    participant B as Backend\n\n    U->>G: Enable Config Mode\n    U->>C: Onboard Gateway\n\n    C->>G: Connect via BLE\n\n    C->>G: GET api/crypto\n    G--\x3e>C: serial & public key\n    C->>U: Display serial & public key\n\n    U->>C: Claim gateway\n    C->>B: Check gateway status (serial)\n    B--\x3e>C: Return gateway info (exists, wallet, location)\n\n    U->>C: Request gateway registration\n    C->>G: POST api/initialize (wallet public key)\n    G--\x3e>C: Return wallet, ID, gateway signature\n\n    C->>B: Initialize gateway (wallet, ID, signature)\n    B--\x3e>C: Confirmation\n\n    U->>C: Provide gateway location\n    C->>U: Request location message signature\n    U--\x3e>C: location message wallet signature\n\n    C->>B: Set gateway location (location message)\n    B--\x3e>C: Location confirmed\n\n    Note over U,B: WiFi Provisioning Process\n\n    U->>C: Complete onboarding\n    C->>G: POST api/ble/stop\n    G--\x3e>C: Status OK\n    Note over G: Optionally Disable BLE & exit config mode\n    C->>G: BLE Disconnect\n\n    C->>U: Request credentials signature\n    U--\x3e>C: Sign gateway credentials"}),(0,i.kt)("h3",{id:"network-connectivity"},"Network Connectivity"),(0,i.kt)("p",null,"Wifi provisioning is done using a few endpoints ",(0,i.kt)("inlineCode",{parentName:"p"},"GET api/wifi"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"POST api/wifi")," and 'GET api/wifi/scan`. We reccomend that the gateway performs a network scan when entering its configuration mode. There is no call to scan per unless the user initiates it."),(0,i.kt)("p",null,"The wifi provisioning process looks like this:"),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    participant U as User\n    participant C as Client\n    participant G as Gateway\n    \n    C->>G: GET api/wifi\n    G--\x3e>C: SSIDs list & current connection status\n    C->>U: Display available networks\n\n    opt User requests refresh\n        U->>C: Scan for networks\n        C->>G: GET api/wifi/scan\n        G--\x3e>C: Scanning...\n        Note over G: Perform WiFi scan\n        G--\x3e>C: Available networks\n        C->>U: Display updated networks\n    end\n\n    U->>C: Select network & provide password\n\n    C->>G: POST api/wifi (ssid, password)\n    Note over G: Attempt connection\n    G--\x3e>C: Connection status\n\n    C->>G: GET api/wifi\n    G--\x3e>C: Connected: selected SSID\n    C->>U: Display connection success"}),(0,i.kt)("h2",{id:"inception-1"},"Inception"),(0,i.kt)("p",null,"The gateway should expose a REST endpoint that accepts the wallet public key. This endpoint should be accessible via BLE or local Network access via mDNS."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'POST api/initialize\n{\n  "wallet":"public_key"\n}\n\nreturns:\n{\n  "idAndWallet": "gateway_id:wallet",\n  "signature": "the signature of the idAndWallet string"\n}\n')),(0,i.kt)("h1",{id:"wallet-recovery"},"Wallet Recovery"),(0,i.kt)("p",null,"For gateways that are integrated into the SEA there is a need for a wallet recovery flow. The purpose is for users to be able to recover their wallet private key if it has been created in the SEA (this is naturally not possible for external wallets such as Phantom). The user will need their recovery key and acces to a gateway they have connected to the wallet. From the gateways perspective this is rather simple, all that is needed is an enpoint that can create a signature based on a message. This endpoint should be accessible via BLE or local Network access via mDNS."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'POST api/crypto/sign\n{\n  "message":"optional message string"\n  "timestamp":"optional timestamp string"\n}\n\nreturns:\n{\n  "message": "[message|]nonce|timestamp ( UTC Y-m-dTH:M:SZ)|serial",\n  "sign": "the signature of the returned message string"},\n}\n\n')),(0,i.kt)("p",null,"Note that if the message is not supplied there should not be a leading ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," included. The message can also not contain the ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," character. If the timestamp is not supplied in the request it should be added in the format sepecified. The reason for being able to inject the timestamp is that some gateways may not have a valid time at the point of recovery."),(0,i.kt)("p",null,"The gateway would need to be put in eg. a mode that enables bluetooth, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"ble/stop")," message will be sent when the flow has finished and the gateway can resume normal operations."),(0,i.kt)("h1",{id:"sen-data-ingress"},"SEN Data Ingress"),(0,i.kt)("p",null,"Gateways send data to the SEN using a signed JSON Web Token (JWT) format. You can read more about the format specification here: ",(0,i.kt)("a",{parentName:"p",href:"https://jwt.io/introduction"},"https://jwt.io/introduction"),". Frequency of sending is 10 seconds, but may be more seldom. You may send several data packages in the same payload of the JWT but the data needs to be from the same energy resource for each JWT. E.g. if a gateway is connected to both an inverter and a meter the data from the inverter needs to be sent in one JWT (with optionally many datapoints) and data from the meter in another JWT (with optionally many datapoints). "),(0,i.kt)("p",null,"In particular, data is ingested using signed JWTs (not encrypted) via HTTPS. I.e., standard safe HTTPS transport is used to perform end-to-end encryption of the data."),(0,i.kt)("h2",{id:"header"},"Header"),(0,i.kt)("p",null,"The header consists of the standard fields plus extra protocol-specific fields."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "alg": "ES256",    \n    "typ": "JWT",\n    "device": "device_id",\n    "opr": "testing",\n    "licence": "device licence key",\n    "developer": "developer licence key",\n    "model": "model string",\n    "dtype": "payload datatype specifics",\n    "sn": "data serial number"\n}\n')),(0,i.kt)("h3",{id:"energy-meter-header-example"},"Energy Meter Header Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "alg": "ES256",\n  "typ": "JWT",\n  "device": "0123752ceb741f6eee",\n  "opr": "production",\n  "model": "p1homewizard",\n  "dtype": "p1_telnet_json",\n  "sn": "LGF5E360"\n}\n')),(0,i.kt)("p",null,"One note is that technically the ",(0,i.kt)("inlineCode",{parentName:"p"},"ES256R")," algorithm/curve is used, that is ECDSA using SECP256r1 curve and SHA-256 and not ECDSA using P-256 curve and SHA-256."),(0,i.kt)("h2",{id:"payload"},"Payload"),(0,i.kt)("p",null,"The body consists of the data the device sends, this data consists of one or more timestamped JSON objects. This is not generally standardized at this point. Timestamps are always in UTC."),(0,i.kt)("h3",{id:"energy-meter-payload-example"},"Energy Meter Payload Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "1739352916813": {\n    "serial_number": "LGF5E360",\n    "rows": [\n      "0-0:1.0.0(250212103510W)",\n      "1-0:1.8.0(00010968.132*kWh)",\n      "1-0:2.8.0(00000000.000*kWh)",\n      "1-0:3.8.0(00000005.151*kVArh)",\n      "1-0:4.8.0(00002109.781*kVArh)",\n      "1-0:1.7.0(0000.253*kW)",\n      "1-0:2.7.0(0000.000*kW)",\n      "1-0:3.7.0(0000.000*kVAr)",\n      "1-0:4.7.0(0000.084*kVAr)",\n      "1-0:21.7.0(0000.064*kW)",\n      "1-0:22.7.0(0000.000*kW)",\n      "1-0:41.7.0(0000.161*kW)",\n      "1-0:42.7.0(0000.000*kW)",\n      "1-0:61.7.0(0000.028*kW)",\n      "1-0:62.7.0(0000.000*kW)",\n      "1-0:23.7.0(0000.000*kVAr)",\n      "1-0:24.7.0(0000.000*kVAr)",\n      "1-0:43.7.0(0000.000*kVAr)",\n      "1-0:44.7.0(0000.052*kVAr)",\n      "1-0:63.7.0(0000.000*kVAr)",\n      "1-0:64.7.0(0000.032*kVAr)",\n      "1-0:32.7.0(233.6*V)",\n      "1-0:52.7.0(233.0*V)",\n      "1-0:72.7.0(232.9*V)",\n      "1-0:31.7.0(000.2*A)",\n      "1-0:51.7.0(000.7*A)",\n      "1-0:71.7.0(000.1*A)",\n      "!0E78"\n    ],\n    "checksum": "0E78"\n  }\n}\n')),(0,i.kt)("h2",{id:"signature"},"Signature"),(0,i.kt)("p",null,"The signature is the signature generated by the device private key that can be verified by the public key."),(0,i.kt)("h3",{id:"full-signed-jwt-energy-meter-example"},"Full Signed JWT Energy Meter Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"eyJhbGciOiAiRVMyNTYiLCAidHlwIjogIkpXVCIsICJkZXZpY2UiOiAiMDEyMzc1MmNlYjc0MWY2ZWVlIiwgIm9wciI6ICJwcm9kdWN0aW9uIiwgIm1vZGVsIjogInAxaG9tZXdpemFyZCIsICJkdHlwZSI6ICJwMV90ZWxuZXRfanNvbiIsICJzbiI6ICJMR0Y1RTM2MCJ9.eyIxNzM5MzUyOTE2ODEzIjogeyJzZXJpYWxfbnVtYmVyIjogIkxHRjVFMzYwIiwgInJvd3MiOiBbIjAtMDoxLjAuMCgyNTAyMTIxMDM1MTBXKSIsICIxLTA6MS44LjAoMDAwMTA5NjguMTMyKmtXaCkiLCAiMS0wOjIuOC4wKDAwMDAwMDAwLjAwMCprV2gpIiwgIjEtMDozLjguMCgwMDAwMDAwNS4xNTEqa1ZBcmgpIiwgIjEtMDo0LjguMCgwMDAwMjEwOS43ODEqa1ZBcmgpIiwgIjEtMDoxLjcuMCgwMDAwLjI1MyprVykiLCAiMS0wOjIuNy4wKDAwMDAuMDAwKmtXKSIsICIxLTA6My43LjAoMDAwMC4wMDAqa1ZBcikiLCAiMS0wOjQuNy4wKDAwMDAuMDg0KmtWQXIpIiwgIjEtMDoyMS43LjAoMDAwMC4wNjQqa1cpIiwgIjEtMDoyMi43LjAoMDAwMC4wMDAqa1cpIiwgIjEtMDo0MS43LjAoMDAwMC4xNjEqa1cpIiwgIjEtMDo0Mi43LjAoMDAwMC4wMDAqa1cpIiwgIjEtMDo2MS43LjAoMDAwMC4wMjgqa1cpIiwgIjEtMDo2Mi43LjAoMDAwMC4wMDAqa1cpIiwgIjEtMDoyMy43LjAoMDAwMC4wMDAqa1ZBcikiLCAiMS0wOjI0LjcuMCgwMDAwLjAwMCprVkFyKSIsICIxLTA6NDMuNy4wKDAwMDAuMDAwKmtWQXIpIiwgIjEtMDo0NC43LjAoM\n")))}u.isMDXComponent=!0}}]);